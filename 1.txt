#include <algorithm>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

// Structure to store trace information
struct Trace {
    int left_start, left_end;    // Indices of the left subproblem
    int right_start, right_end;  // Indices of the right subproblem
};

// Structure for each DP entry
struct DPEntry {
    vector<int> values;               // Stores unique results
    unordered_map<int, Trace> trace;  // Maps result -> Trace
};

// Function to calculate the result of i âŠ• j using the operation table
int operate(const vector<vector<int>> &table, int i, int j) {
    return table[i - 1][j - 1];
}

// Helper function to reconstruct the expression from trace
string reconstructExpression(int start, int end, int result,
                             const vector<vector<DPEntry>> &dp) {
    if (start == end) {
        return to_string(
            dp[start][start].values[0]);  // Base case: single number
    }

    // Ensure the result exists in the trace map
    if (dp[start][end].trace.find(result) == dp[start][end].trace.end()) {
        throw logic_error("Result not found in trace during reconstruction.");
    }

    Trace t = dp[start][end].trace.at(result);

    string left_expr = reconstructExpression(
        t.left_start, t.left_end, dp[t.left_start][t.left_end].values[0], dp);
    string right_expr =
        reconstructExpression(t.right_start, t.right_end,
                              dp[t.right_start][t.right_end].values[0], dp);

    return "(" + left_expr + " " + right_expr + ")";
}

// Function to solve the problem using dynamic programming
string solve(const vector<int> &sequence, const vector<vector<int>> &table,
             int desiredResult, int n) {
    int m = sequence.size();
    vector<vector<DPEntry>> dp(m, vector<DPEntry>(m));

    // Initialize base cases for intervals of size 1
    for (int i = 0; i < m; ++i) {
        dp[i][i].values.push_back(sequence[i]);
        dp[i][i].trace[sequence[i]] = {-1, -1, -1,
                                       -1};  // No split for base case
    }

    // Fill the DP table for intervals of increasing length
    for (int len = 2; len <= m; ++len) {  // len is the interval size
        for (int start = 0; start <= m - len; ++start) {
            int end = start + len - 1;  // End of the interval

            for (int k = end; k > start; --k) {  // Split point
                if (dp[start][end].values.size() >= static_cast<size_t>(n)) {
                    break;  // Limit the number of stored results
                }

                for (int &left : dp[start][k - 1].values) {
                    for (int &right : dp[k][end].values) {
                        int result = operate(table, left, right);

                        // Only store unique results
                        if (find(dp[start][end].values.begin(),
                                 dp[start][end].values.end(),
                                 result) == dp[start][end].values.end()) {
                            dp[start][end].values.push_back(result);

                            // Ensure trace entry is added
                            dp[start][end].trace[result] = {start, k - 1, k,
                                                            end};
                        }
                    }
                }
            }
        }
    }

    // Print the DP table
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < m; ++j) {
            cout << "dp[" << i << "][" << j << "]: ";
            for (const auto &res : dp[i][j].values) {
                cout << res << " ";
            }
            cout << endl;
        }
    }

    // Check if the desired result can be achieved and reconstruct the
    // expression
    for (int result : dp[0][m - 1].values) {
        if (result == desiredResult) {
            return reconstructExpression(0, m - 1, desiredResult, dp);
        }
    }

    return "";  // Return an empty string if no solution is found
}

int main() {
    // Read input
    int n, m;
    scanf("%d %d", &n, &m);

    vector<vector<int>> table(n, vector<int>(n));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j) scanf("%d", &table[i][j]);

    vector<int> sequence(m);
    for (int i = 0; i < m; ++i) scanf("%d", &sequence[i]);

    int desiredResult;
    scanf("%d", &desiredResult);

    // Solve the problem
    string solution = solve(sequence, table, desiredResult, n);

    // Print results
    if (solution.empty()) {
        printf("0\n");
    } else {
        printf("1\n");
        printf("%s\n", solution.c_str());
    }

    return 0;
}
